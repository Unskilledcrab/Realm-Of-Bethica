@using ROB.Blazor.Shared.Interfaces.CombatTracker

<div class="character faction-@Character.Faction.ToString().ToLower() @(Character == ActiveCharacter ? $"faction-{Character.Faction.ToString().ToLower()}-active" : "")">
    <div class="character-targeted character-targeted-@Character.Faction.ToString().ToLower()" hidden="@_crosshairHidden"></div>
    <div class="grid-char-bar">
        <span class="oi oi-person tooltip-handle" @onclick="@(()=>TargetEnd(Character))">
            <span class="tooltip-text">Target</span>
        </span>
        <span>@Character.Name (@Character.Dem)</span>
        @foreach (var stat in Character.GetCharBarStats())
        {
            <input @bind="@stat.Value" readonly />
        }
        <span class="oi oi-shield tooltip-handle" @onclick=@(()=>FactionToggle(Character))>
            <span class="tooltip-text">@Character.Faction.ToString()</span>
        </span><!-- faction -->
        <span class="oi oi-target" @onclick="@(() =>ToggleStatSectionVisible("targets"))" style="color:@(Character.GetFactionColor(_targetHidden))"></span><!-- target -->
        <span class="oi oi-list" @onclick="@(()=>ToggleStatSectionVisible("attributes"))" style="color:@(Character.GetFactionColor(_attrHidden))"></span><!-- attributes -->
        <span class="oi oi-eyedropper" @onclick="@(()=>ToggleStatSectionVisible("offense"))" style="color:@(Character.GetFactionColor(_offenseHidden))"></span><!-- offense -->
        <span class="oi oi-pulse" @onclick="@(()=>ToggleStatSectionVisible("effects"))" style="color:@(Character.GetFactionColor(_effectsHidden))"></span><!-- effects -->
        <span class="oi oi-clipboard" @onclick="@(()=>CharacterSheetClicked(Character))"></span><!-- open char sheet -->
    </div>

    <CharacterTargetComponent Hidden="@_targetHidden" />
    <CharacterAttributesComponent Hidden="@_attrHidden" />
    <CharacterOffenseComponent Hidden="@_offenseHidden" />
    <CharacterEffectsComponent Hidden="@_effectsHidden" />

</div>

@code {
    [CascadingParameter(Name = "Character")]
    protected ICharacter Character { get; set; }

    [CascadingParameter(Name = "ActiveCharacter")]
    protected ICharacter ActiveCharacter { get => _activeCharacter; set { _activeCharacter = value; _crosshairHidden = true; } }

    private ICharacter _activeCharacter;

    [Parameter]
    public Action<string> LogAction { get; set; }

    [Parameter]
    public Action<ICharacter> OpenCharacterSheet { get; set; }

    private bool _targetHidden = true;
    private bool _attrHidden = true;
    private bool _offenseHidden = true;
    private bool _effectsHidden = true;
    private bool _crosshairHidden = true;

    protected override async Task OnInitializedAsync()
    {
        await Task.Run(() =>
        {
            Character.TargetedStateChanged += UpdateCrosshair;
            Character.FactionChanged += StateHasChanged;
            Character.StatsChanged += StateHasChanged;
        });
    }

    public void Dispose()
    {
        Character.TargetedStateChanged -= UpdateCrosshair;
    }

    private void UpdateCrosshair()
    {
        _crosshairHidden = !IsTargeted(Character);
        StateHasChanged();
    }

    private void FactionToggle(ICharacter character)
    {
        int factionsCount = Enum.GetNames(typeof(ICharacter.FactionType)).Length;
        character.Faction = (ICharacter.FactionType)((((int)character.Faction) + 1) % factionsCount);
    }

    private void TargetEnd(ICharacter targetCharacter)
    {
        if (ActiveCharacter.Targets.Contains(targetCharacter))
        {
            ActiveCharacter.RemoveTarget(targetCharacter);
        }
        else
        {
            ActiveCharacter.AddTarget(targetCharacter);
        }
    }

    private bool IsTargeted(ICharacter targetCharacter)
    {
        if (!ActiveCharacter.Targets.Contains(targetCharacter))
        {
            if (targetCharacter == ActiveCharacter)
                LogAction?.Invoke($"{ActiveCharacter.Name} decides against including {ActiveCharacter.PronounHimselfHerself()}.");
            else
                LogAction?.Invoke($"{ActiveCharacter.Name} forgets about {targetCharacter.Name}.");

            return false;
        }
        else
        {
            if (targetCharacter == ActiveCharacter)
                LogAction?.Invoke($"{ActiveCharacter.Name} considers including {ActiveCharacter.PronounHimselfHerself()} in {ActiveCharacter.PronounHisHer()} next action.");
            else
                LogAction?.Invoke($"{ActiveCharacter.Name} leers menacingly at {targetCharacter.Name}.");

            return true;
        }
    }

    private async void ToggleStatSectionVisible(string section)
    {
        bool initialState = true;

        if (section == "targets")
        {
            initialState = _targetHidden;
        }
        else if (section == "attributes")
        {
            initialState = _attrHidden;
        }
        else if (section == "offense")
        {
            initialState = _offenseHidden;
        }
        else if (section == "effects")
        {
            initialState = _effectsHidden;
        }

        if (!_targetHidden || !_attrHidden || !_offenseHidden || !_effectsHidden)
        {
            _targetHidden = true;
            _attrHidden = true;
            _offenseHidden = true;
            _effectsHidden = true;

            await Task.Delay(1000);
        }


        if (section == "targets" && initialState)
        {
            _targetHidden = false;
        }
        else if (section == "attributes" && initialState)
        {
            _attrHidden = false;
        }
        else if (section == "offense" && initialState)
        {
            _offenseHidden = false;
        }
        else if (section == "effects" && initialState)
        {
            _effectsHidden = false;
        }
        else
        {
            _targetHidden = true;
            _attrHidden = true;
            _offenseHidden = true;
            _effectsHidden = true;
        }

        StateHasChanged();
    }

    private void CharacterSheetClicked(ICharacter character)
    {
        OpenCharacterSheet?.Invoke(character);
    }
}
